**12.ATTRIBUTES OF ARIES**  
ARIES对数据或其模型做了少量的假设，并且相比其他恢复方法有一些优势。ARIES很简单，并且它拥有一些有趣并且实用的特性。正如最后一节总结的，这些特性中的大多数已经运用到现有的一些系统中了。然而，还有没有哪个单独的系统能拥有其所有特性。ARIES的特性如下：  
（1）支持优于页级别的并行控制，并且支持多种颗粒度锁。ARIES以统一的方式支持页级别和记录级别的锁。恢复并不受使用哪种锁颗粒度影响。依赖于数据的竞争模型，选择合适的锁级别。它同样允许多种锁级别并存（比如，记录级，表级，表空间级别）。除了锁，也可以使用并行控制策略。（比如【2】中提到的策略）。  
（2）在重启或正常流程时使用灵活的缓存管理。一旦遵循了日志先行协议，缓存管理就可以使用任意页替换策略。比如，在事务提交之前，这些事务需要将脏页落地（steal 策略）。同样，也可以不要求在事务提交前刷出所有脏页（比如：no-force策略）。这些特性降低了对缓存的要求，并且减少了对更新（热点）页的频繁调用。ARIES并不排除使用延迟更新或者强制提交策略，而且可以得益于他们。ARIES在这些方面是非常灵活的。  
（3）Minimal space overhead–only one LSN per page。持久化（不包括日志）空间负载受限于每个页上存储的LSN，记录该页上最近一次动作。页LSn通常是单调增长的值。  
（4）对数据无限制以确保redo或者undo的幂等性。数据上没有限制，比如唯一key等等。记录可以是变长的。数据可以在页内移动以便垃圾回收。操作的幂等性是通过每个页上的LSN来确保的，通过LSN来决定某个操作是否要redo。  
（5）某个更新的undo顺序不需要和原始操作顺序完全逆序。由于在Undo的时候会写CLR，原操作的逆序和实际进行的undo可以在之前就记录下来。有一个例子说明完全的逆序并不一定正确，关于数据页的空闲空间信息的（类似，10%空闲，20%空闲），这些是在空间映射页中维护的。因为使用了优于页级的锁，某个事务在开始更新一个页是，表空间信息不会发生变更，在undo的时候空闲空间信息可能发生了变更，因为其他事务的一些逆操作（参见10.3节）。  
关于基于Hash存储方案和索引管理的优点在【59,62】有详细讨论。  
（6）支持操作日志和特殊锁模型。对于某页的变更可以以逻辑方式记录。对于这个对象的undo和redo信息就都不需要记录日志了。如果只有变更的字段被记录也是完全够用了。由于历史重演，对于自增自减这种操作，就不需要该字段的变更前后数据镜像。知道这种操作的减少或增加的量就足够了。垃圾回收器的动作并且对页的一些字段的更新（比如：空闲空间的大小）不需要记录日志。特殊锁模型是基于操作的可交换性以及一些其他特性才能支持的【2,26,88】  
（7）redo-only和undo-only记录都是适用的。它们有时候是很高效的（对日志组件只调用一次），在同一条记录中包含了undo和redo信息。在其他时候，它可能是高效的（undo记录可以从源数据构建，在对数据原地更新之后，从更新的数据可以构建redo记录），可能是必须的（因为日志大小限制）以不同的记录来记录信息。ARIES都可以处理这两种情形。在这些情况下，undo记录必须在redo记录之前记录。  
（8）支持部分和全部回滚。除了允许事务全部回滚，ARIES还支持构建savepoint，并且允许事务回滚到这些savepoint。若不支持部分回滚，甚至一些逻辑恢复错误（比如：唯一key违反，分布式系统中的缓存目录信息过期）都会要求全部回滚，这便浪费了很多工作。  
（9）支持对象跨越多个页。对象可以跨越多个页（比如：IMS中的记录可以包含多数据段，并分散在很多页上）。当某个对象变更了，如果对每个页的更新都做了日志记录，ARIES就能很好的工作。ARIES本身并不会特别处理多个页的对象。  
（10）允许在任意时刻从操作系统获取和归还文件。ARIES提供了对动态的永久的归还文件给操作系统的灵活性（参见【19】节中有对这一技术的详细讨论）。这样的操作是不能undo。它也不能阻止同样的文件被数据库系统重分配。System R并没有要求对象（比如表空间）和文件之间的静态映射。