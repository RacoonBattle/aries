3 OVERVIEW OF ARIES

本章节的主要是对Aries协议的概述，它恰如其分的满足了我们在第二节设定的那些目标。像延迟恢复，选择恢复，重启恢复时的并发模型，等等，将会在该论文的其他章节进行讨论。

在（进程，事务，系统，介质）发生奔溃情况下，ARIES保证了事务的原子性和持久性。为此，ARIES通过使用日志先行（WAL）的方式来跟踪对数据库所做的变更操作。除了记录日志，以一个影响页为基准，在事务执行更新的时候，ARIES同样也会记录（通常使用补偿日志记录CLRs[compensation log records]）事务的部分或者全部回滚的操作。图3给出了一种部分回滚的例子，该事务先执行了3次操作，然后回滚了2个，接着继续执行。由于有两个变更的undo,会写两个CLRs。在ARIES中，CLRs都是redo-only日志记录。通过合理的将CLRs和日志记录串连起来，就能确定一个有限的日志记录，甚至在重启或者嵌套回滚时重复失效也能如此。与之相反的就是IMS,它可能会执行多次相同的non-CLR，在AS/400, DB2 and NonStop SQL中，除了会多次执行相同的non-CLR，也会undo CLR一次或多次（参考图4）。这已经导致了现实中客户系统的一系列问题。

在ARIES中，如图5所示，当一条日志记录的undo触发了一个CLR的写入，该CLR除了包含这个对redo操作的补偿信息外，它同样会包含一个UndoNxtLSN来指向这个条回滚日志的前置记录。由于每条日志（包括CLR）包含了PrevLSN指针，指向同一事务的先前的最近的一条日志，因此，该前置信息是完全可用的。通过UndoNxtLSN指针，我们可以精确判断出该事务中还有多少操作没有undo。在图5中，日志3'（日志3的CLR）,指向日志2（日志3的前置日志）。从而在回滚的时候，最新写入的CLR中的UndoNxtLSN字段标识了其回滚的进度。当由于系统奔溃而中断了回滚操作或者是在执行嵌套回滚的时候，通过UndoNxtLSN字段，就可以知道从什么地方继续该事务的回滚操作。这使得系统可以跳过那些已经做过的回退操作。根据影响的页和原始操作的逆向操作，CLR可以描述在undo时，哪些操作确实执行了，哪些操作并不需要执行。也就是说，可以支持高并发的逻辑回退了。例如：

![](./img/fig3.png)

![](./img/fig4.png)