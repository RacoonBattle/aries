**6.RESTART PROCESSIONG重启流程**  
当事务型系统崩溃后重启，恢复策略需要保证数据的一致性和事务的原子性和持久性。图9描述了在系统重启恢复时起始调用的RESTART例程。该例程的的输入是master record的LSN,它包含了系统奔溃前的最后一次完整checkpoint的begin_chkpt记录的指针。该例程顺序触发分析遍历，redo遍历和undo遍历。缓存池的脏页表也会恰当的进行更新。在恢复结束后，会执行一次checkpoint.  
考虑到高可用性，重启流程的耗时必须尽可能的短。达到此目标的一种方法就是并行进行redo遍历和undo遍历。只有当使用并发遍历的时候，才需要在修改页数据的时候加闩。最理想的情况就是在重启恢复过程中，仍然允许执行新事务，参见[60]。 
![](./img/fig9.png)  
**6.1Analysis Pass 分析遍历**  
重启恢复流程中第一次遍历就analysis pass。图10描述RESTART_ANALYSIS例程是如何执行这些遍历动作的。该例程的输入是master记录的LSN。输出是一个包含处于in-doubt或unprepared态的事务列表，一个包含可能是脏页的列表，和RedoLSN（标识redo遍历需要从哪边开始处理日志）。该例程唯一会写的日志记录就是事务的end记录（在系统崩溃前事务已经完全回滚，但是丢失了end记录）。  
在遍历过程中，如果一条日志记录所对应的页并不在脏页表中，那么就会在表中生成一个实例并用当前记录的LSN作为其也的RecLSN。同时通过修改事务表跟踪这些事务的状态变更，并且记录最近一次日志的LSN以便在确定这个事务需要回滚的后做undo。如果遇到OSfile_return日志记录，该文件中的页如果在脏页表中，那么就会被移除，以确保在redo遍历的时候不会访问到该文件的这个版本的页。一旦导致文件删除的原始操作提交了，相同的文件会在随后被重写创建和更新。在这种情况下，重建的文件中的页会出现在脏页表中，它们的RecLSN值会比文件删除时的日志结尾的LSN要大。在分析遍历结束后，RedoLSN为脏页表中的最小的RecLSN值。如果脏页表为空，那么就可以跳过redo遍历。  
其实并不需要独立做一次分析遍历，在0S/2 Extended Edition Database Manager实现的ARIES中就没有分析遍历。这很特殊，因为正如我们之前提到的（参见6.2节），在redo遍历时，ARIES无条件的redo所有丢失的更新。也就是说，不管他们的记录的是失败的还是没有失败的事务，都会redo，这一点和System R,SQL/DS,DB2不同。因此，redo并不需要知道事务是否失败。这个信息严格的来说对undo遍历有用。
